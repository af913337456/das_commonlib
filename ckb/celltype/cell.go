// Generated by Molecule 0.6.1

package celltype

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type ActionDataBuilder struct {
	action Bytes
	params Bytes
}

func (s *ActionDataBuilder) Build() ActionData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.action.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.params.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.action.AsSlice())
	b.Write(s.params.AsSlice())
	return ActionData{inner: b.Bytes()}
}

func (s *ActionDataBuilder) Action(v Bytes) *ActionDataBuilder {
	s.action = v
	return s
}

func (s *ActionDataBuilder) Params(v Bytes) *ActionDataBuilder {
	s.params = v
	return s
}

func NewActionDataBuilder() *ActionDataBuilder {
	return &ActionDataBuilder{action: BytesDefault(), params: BytesDefault()}
}

type ActionData struct {
	inner []byte
}

func ActionDataFromSliceUnchecked(slice []byte) *ActionData {
	return &ActionData{inner: slice}
}
func (s *ActionData) AsSlice() []byte {
	return s.inner
}

func ActionDataDefault() ActionData {
	return *ActionDataFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ActionDataFromSlice(slice []byte, compatible bool) (*ActionData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &ActionData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ActionData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ActionData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &ActionData{inner: slice}, nil
}

func (s *ActionData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ActionData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ActionData) Len() uint {
	return s.FieldCount()
}
func (s *ActionData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ActionData) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *ActionData) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *ActionData) Action() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ActionData) Params() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ActionData) AsBuilder() ActionDataBuilder {
	ret := NewActionDataBuilder().Action(*s.Action()).Params(*s.Params())
	return *ret
}

type ConfigCellDataBuilder struct {
	reserved_account_filter                   Bytes
	proposal_min_confirm_require              Uint8
	proposal_min_extend_interval              Uint8
	proposal_max_account_affect               Uint32
	proposal_max_pre_account_contain          Uint32
	apply_min_waiting_time                    Uint32
	apply_max_waiting_time                    Uint32
	account_max_length                        Uint32
	price_configs                             PriceConfigList
	char_sets                                 CharSetList
	min_ttl                                   Uint32
	closing_limit_of_primary_market_auction   Uint32
	closing_limit_of_secondary_market_auction Uint32
	type_id_table                             TypeIdTable
}

func (s *ConfigCellDataBuilder) Build() ConfigCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (14 + 1)
	offsets := make([]uint32, 0, 14)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.reserved_account_filter.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_min_confirm_require.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_min_extend_interval.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_max_account_affect.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_max_pre_account_contain.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_min_waiting_time.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_max_waiting_time.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_max_length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price_configs.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.char_sets.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.min_ttl.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.closing_limit_of_primary_market_auction.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.closing_limit_of_secondary_market_auction.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_id_table.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.reserved_account_filter.AsSlice())
	b.Write(s.proposal_min_confirm_require.AsSlice())
	b.Write(s.proposal_min_extend_interval.AsSlice())
	b.Write(s.proposal_max_account_affect.AsSlice())
	b.Write(s.proposal_max_pre_account_contain.AsSlice())
	b.Write(s.apply_min_waiting_time.AsSlice())
	b.Write(s.apply_max_waiting_time.AsSlice())
	b.Write(s.account_max_length.AsSlice())
	b.Write(s.price_configs.AsSlice())
	b.Write(s.char_sets.AsSlice())
	b.Write(s.min_ttl.AsSlice())
	b.Write(s.closing_limit_of_primary_market_auction.AsSlice())
	b.Write(s.closing_limit_of_secondary_market_auction.AsSlice())
	b.Write(s.type_id_table.AsSlice())
	return ConfigCellData{inner: b.Bytes()}
}

func (s *ConfigCellDataBuilder) ReservedAccountFilter(v Bytes) *ConfigCellDataBuilder {
	s.reserved_account_filter = v
	return s
}

func (s *ConfigCellDataBuilder) ProposalMinConfirmRequire(v Uint8) *ConfigCellDataBuilder {
	s.proposal_min_confirm_require = v
	return s
}

func (s *ConfigCellDataBuilder) ProposalMinExtendInterval(v Uint8) *ConfigCellDataBuilder {
	s.proposal_min_extend_interval = v
	return s
}

func (s *ConfigCellDataBuilder) ProposalMaxAccountAffect(v Uint32) *ConfigCellDataBuilder {
	s.proposal_max_account_affect = v
	return s
}

func (s *ConfigCellDataBuilder) ProposalMaxPreAccountContain(v Uint32) *ConfigCellDataBuilder {
	s.proposal_max_pre_account_contain = v
	return s
}

func (s *ConfigCellDataBuilder) ApplyMinWaitingTime(v Uint32) *ConfigCellDataBuilder {
	s.apply_min_waiting_time = v
	return s
}

func (s *ConfigCellDataBuilder) ApplyMaxWaitingTime(v Uint32) *ConfigCellDataBuilder {
	s.apply_max_waiting_time = v
	return s
}

func (s *ConfigCellDataBuilder) AccountMaxLength(v Uint32) *ConfigCellDataBuilder {
	s.account_max_length = v
	return s
}

func (s *ConfigCellDataBuilder) PriceConfigs(v PriceConfigList) *ConfigCellDataBuilder {
	s.price_configs = v
	return s
}

func (s *ConfigCellDataBuilder) CharSets(v CharSetList) *ConfigCellDataBuilder {
	s.char_sets = v
	return s
}

func (s *ConfigCellDataBuilder) MinTtl(v Uint32) *ConfigCellDataBuilder {
	s.min_ttl = v
	return s
}

func (s *ConfigCellDataBuilder) ClosingLimitOfPrimaryMarketAuction(v Uint32) *ConfigCellDataBuilder {
	s.closing_limit_of_primary_market_auction = v
	return s
}

func (s *ConfigCellDataBuilder) ClosingLimitOfSecondaryMarketAuction(v Uint32) *ConfigCellDataBuilder {
	s.closing_limit_of_secondary_market_auction = v
	return s
}

func (s *ConfigCellDataBuilder) TypeIdTable(v TypeIdTable) *ConfigCellDataBuilder {
	s.type_id_table = v
	return s
}

func NewConfigCellDataBuilder() *ConfigCellDataBuilder {
	return &ConfigCellDataBuilder{reserved_account_filter: BytesDefault(), proposal_min_confirm_require: Uint8Default(), proposal_min_extend_interval: Uint8Default(), proposal_max_account_affect: Uint32Default(), proposal_max_pre_account_contain: Uint32Default(), apply_min_waiting_time: Uint32Default(), apply_max_waiting_time: Uint32Default(), account_max_length: Uint32Default(), price_configs: PriceConfigListDefault(), char_sets: CharSetListDefault(), min_ttl: Uint32Default(), closing_limit_of_primary_market_auction: Uint32Default(), closing_limit_of_secondary_market_auction: Uint32Default(), type_id_table: TypeIdTableDefault()}
}

type ConfigCellData struct {
	inner []byte
}

func ConfigCellDataFromSliceUnchecked(slice []byte) *ConfigCellData {
	return &ConfigCellData{inner: slice}
}
func (s *ConfigCellData) AsSlice() []byte {
	return s.inner
}

func ConfigCellDataDefault() ConfigCellData {
	return *ConfigCellDataFromSliceUnchecked([]byte{142, 1, 0, 0, 60, 0, 0, 0, 64, 0, 0, 0, 65, 0, 0, 0, 66, 0, 0, 0, 70, 0, 0, 0, 74, 0, 0, 0, 78, 0, 0, 0, 82, 0, 0, 0, 86, 0, 0, 0, 90, 0, 0, 0, 94, 0, 0, 0, 98, 0, 0, 0, 102, 0, 0, 0, 106, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0, 132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ConfigCellDataFromSlice(slice []byte, compatible bool) (*ConfigCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 14 == 0 {
		return &ConfigCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ConfigCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ConfigCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 14 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 14 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ConfigCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PriceConfigListFromSlice(slice[offsets[8]:offsets[9]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = CharSetListFromSlice(slice[offsets[9]:offsets[10]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[10]:offsets[11]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[11]:offsets[12]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[12]:offsets[13]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TypeIdTableFromSlice(slice[offsets[13]:offsets[14]], compatible)
	if err != nil {
		return nil, err
	}

	return &ConfigCellData{inner: slice}, nil
}

func (s *ConfigCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ConfigCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ConfigCellData) Len() uint {
	return s.FieldCount()
}
func (s *ConfigCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ConfigCellData) CountExtraFields() uint {
	return s.FieldCount() - 14
}

func (s *ConfigCellData) HasExtraFields() bool {
	return 14 != s.FieldCount()
}

func (s *ConfigCellData) ReservedAccountFilter() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ProposalMinConfirmRequire() *Uint8 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ProposalMinExtendInterval() *Uint8 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ProposalMaxAccountAffect() *Uint32 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ProposalMaxPreAccountContain() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ApplyMinWaitingTime() *Uint32 {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ApplyMaxWaitingTime() *Uint32 {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) AccountMaxLength() *Uint32 {
	start := unpackNumber(s.inner[32:])
	end := unpackNumber(s.inner[36:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) PriceConfigs() *PriceConfigList {
	start := unpackNumber(s.inner[36:])
	end := unpackNumber(s.inner[40:])
	return PriceConfigListFromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) CharSets() *CharSetList {
	start := unpackNumber(s.inner[40:])
	end := unpackNumber(s.inner[44:])
	return CharSetListFromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) MinTtl() *Uint32 {
	start := unpackNumber(s.inner[44:])
	end := unpackNumber(s.inner[48:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ClosingLimitOfPrimaryMarketAuction() *Uint32 {
	start := unpackNumber(s.inner[48:])
	end := unpackNumber(s.inner[52:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) ClosingLimitOfSecondaryMarketAuction() *Uint32 {
	start := unpackNumber(s.inner[52:])
	end := unpackNumber(s.inner[56:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *ConfigCellData) TypeIdTable() *TypeIdTable {
	var ret *TypeIdTable
	start := unpackNumber(s.inner[56:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[60:])
		ret = TypeIdTableFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TypeIdTableFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ConfigCellData) AsBuilder() ConfigCellDataBuilder {
	ret := NewConfigCellDataBuilder().ReservedAccountFilter(*s.ReservedAccountFilter()).ProposalMinConfirmRequire(*s.ProposalMinConfirmRequire()).ProposalMinExtendInterval(*s.ProposalMinExtendInterval()).ProposalMaxAccountAffect(*s.ProposalMaxAccountAffect()).ProposalMaxPreAccountContain(*s.ProposalMaxPreAccountContain()).ApplyMinWaitingTime(*s.ApplyMinWaitingTime()).ApplyMaxWaitingTime(*s.ApplyMaxWaitingTime()).AccountMaxLength(*s.AccountMaxLength()).PriceConfigs(*s.PriceConfigs()).CharSets(*s.CharSets()).MinTtl(*s.MinTtl()).ClosingLimitOfPrimaryMarketAuction(*s.ClosingLimitOfPrimaryMarketAuction()).ClosingLimitOfSecondaryMarketAuction(*s.ClosingLimitOfSecondaryMarketAuction()).TypeIdTable(*s.TypeIdTable())
	return *ret
}

type PriceConfigListBuilder struct {
	inner []PriceConfig
}

func (s *PriceConfigListBuilder) Build() PriceConfigList {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return PriceConfigList{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return PriceConfigList{inner: b.Bytes()}
}

func (s *PriceConfigListBuilder) Set(v []PriceConfig) *PriceConfigListBuilder {
	s.inner = v
	return s
}
func (s *PriceConfigListBuilder) Push(v PriceConfig) *PriceConfigListBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *PriceConfigListBuilder) Extend(iter []PriceConfig) *PriceConfigListBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewPriceConfigListBuilder() *PriceConfigListBuilder {
	return &PriceConfigListBuilder{[]PriceConfig{}}
}

type PriceConfigList struct {
	inner []byte
}

func PriceConfigListFromSliceUnchecked(slice []byte) *PriceConfigList {
	return &PriceConfigList{inner: slice}
}
func (s *PriceConfigList) AsSlice() []byte {
	return s.inner
}

func PriceConfigListDefault() PriceConfigList {
	return *PriceConfigListFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func PriceConfigListFromSlice(slice []byte, compatible bool) (*PriceConfigList, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &PriceConfigList{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfigList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfigList"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := PriceConfigFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &PriceConfigList{inner: slice}, nil
}

func (s *PriceConfigList) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PriceConfigList) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PriceConfigList) Len() uint {
	return s.ItemCount()
}
func (s *PriceConfigList) IsEmpty() bool {
	return s.Len() == 0
}

// if *PriceConfig is nil, index is out of bounds
func (s *PriceConfigList) Get(index uint) *PriceConfig {
	var b *PriceConfig
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = PriceConfigFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = PriceConfigFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *PriceConfigList) AsBuilder() PriceConfigListBuilder {
	size := s.ItemCount()
	t := NewPriceConfigListBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type PriceConfigBuilder struct {
	length Uint8
	new    Uint64
	renew  Uint64
}

func (s *PriceConfigBuilder) Build() PriceConfig {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.length.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.new.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.renew.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.length.AsSlice())
	b.Write(s.new.AsSlice())
	b.Write(s.renew.AsSlice())
	return PriceConfig{inner: b.Bytes()}
}

func (s *PriceConfigBuilder) Length(v Uint8) *PriceConfigBuilder {
	s.length = v
	return s
}

func (s *PriceConfigBuilder) New(v Uint64) *PriceConfigBuilder {
	s.new = v
	return s
}

func (s *PriceConfigBuilder) Renew(v Uint64) *PriceConfigBuilder {
	s.renew = v
	return s
}

func NewPriceConfigBuilder() *PriceConfigBuilder {
	return &PriceConfigBuilder{length: Uint8Default(), new: Uint64Default(), renew: Uint64Default()}
}

type PriceConfig struct {
	inner []byte
}

func PriceConfigFromSliceUnchecked(slice []byte) *PriceConfig {
	return &PriceConfig{inner: slice}
}
func (s *PriceConfig) AsSlice() []byte {
	return s.inner
}

func PriceConfigDefault() PriceConfig {
	return *PriceConfigFromSliceUnchecked([]byte{33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func PriceConfigFromSlice(slice []byte, compatible bool) (*PriceConfig, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &PriceConfig{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PriceConfig", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PriceConfig", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &PriceConfig{inner: slice}, nil
}

func (s *PriceConfig) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PriceConfig) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PriceConfig) Len() uint {
	return s.FieldCount()
}
func (s *PriceConfig) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PriceConfig) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *PriceConfig) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *PriceConfig) Length() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *PriceConfig) New() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *PriceConfig) Renew() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PriceConfig) AsBuilder() PriceConfigBuilder {
	ret := NewPriceConfigBuilder().Length(*s.Length()).New(*s.New()).Renew(*s.Renew())
	return *ret
}

type CharSetListBuilder struct {
	inner []CharSet
}

func (s *CharSetListBuilder) Build() CharSetList {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return CharSetList{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return CharSetList{inner: b.Bytes()}
}

func (s *CharSetListBuilder) Set(v []CharSet) *CharSetListBuilder {
	s.inner = v
	return s
}
func (s *CharSetListBuilder) Push(v CharSet) *CharSetListBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *CharSetListBuilder) Extend(iter []CharSet) *CharSetListBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewCharSetListBuilder() *CharSetListBuilder {
	return &CharSetListBuilder{[]CharSet{}}
}

type CharSetList struct {
	inner []byte
}

func CharSetListFromSliceUnchecked(slice []byte) *CharSetList {
	return &CharSetList{inner: slice}
}
func (s *CharSetList) AsSlice() []byte {
	return s.inner
}

func CharSetListDefault() CharSetList {
	return *CharSetListFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func CharSetListFromSlice(slice []byte, compatible bool) (*CharSetList, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSetList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &CharSetList{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSetList", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CharSetList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSetList"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := CharSetFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &CharSetList{inner: slice}, nil
}

func (s *CharSetList) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *CharSetList) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *CharSetList) Len() uint {
	return s.ItemCount()
}
func (s *CharSetList) IsEmpty() bool {
	return s.Len() == 0
}

// if *CharSet is nil, index is out of bounds
func (s *CharSetList) Get(index uint) *CharSet {
	var b *CharSet
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = CharSetFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = CharSetFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *CharSetList) AsBuilder() CharSetListBuilder {
	size := s.ItemCount()
	t := NewCharSetListBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type CharSetBuilder struct {
	name   Uint32
	global Uint8
	chars  Chars
}

func (s *CharSetBuilder) Build() CharSet {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.name.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.global.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.chars.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.name.AsSlice())
	b.Write(s.global.AsSlice())
	b.Write(s.chars.AsSlice())
	return CharSet{inner: b.Bytes()}
}

func (s *CharSetBuilder) Name(v Uint32) *CharSetBuilder {
	s.name = v
	return s
}

func (s *CharSetBuilder) Global(v Uint8) *CharSetBuilder {
	s.global = v
	return s
}

func (s *CharSetBuilder) Chars(v Chars) *CharSetBuilder {
	s.chars = v
	return s
}

func NewCharSetBuilder() *CharSetBuilder {
	return &CharSetBuilder{name: Uint32Default(), global: Uint8Default(), chars: CharsDefault()}
}

type CharSet struct {
	inner []byte
}

func CharSetFromSliceUnchecked(slice []byte) *CharSet {
	return &CharSet{inner: slice}
}
func (s *CharSet) AsSlice() []byte {
	return s.inner
}

func CharSetDefault() CharSet {
	return *CharSetFromSliceUnchecked([]byte{25, 0, 0, 0, 16, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func CharSetFromSlice(slice []byte, compatible bool) (*CharSet, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSet", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &CharSet{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "CharSet", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "CharSet", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = CharsFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &CharSet{inner: slice}, nil
}

func (s *CharSet) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *CharSet) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *CharSet) Len() uint {
	return s.FieldCount()
}
func (s *CharSet) IsEmpty() bool {
	return s.Len() == 0
}
func (s *CharSet) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *CharSet) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *CharSet) Name() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *CharSet) Global() *Uint8 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *CharSet) Chars() *Chars {
	var ret *Chars
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = CharsFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = CharsFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *CharSet) AsBuilder() CharSetBuilder {
	ret := NewCharSetBuilder().Name(*s.Name()).Global(*s.Global()).Chars(*s.Chars())
	return *ret
}

type CharsBuilder struct {
	inner []Bytes
}

func (s *CharsBuilder) Build() Chars {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Chars{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Chars{inner: b.Bytes()}
}

func (s *CharsBuilder) Set(v []Bytes) *CharsBuilder {
	s.inner = v
	return s
}
func (s *CharsBuilder) Push(v Bytes) *CharsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *CharsBuilder) Extend(iter []Bytes) *CharsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewCharsBuilder() *CharsBuilder {
	return &CharsBuilder{[]Bytes{}}
}

type Chars struct {
	inner []byte
}

func CharsFromSliceUnchecked(slice []byte) *Chars {
	return &Chars{inner: slice}
}
func (s *Chars) AsSlice() []byte {
	return s.inner
}

func CharsDefault() Chars {
	return *CharsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func CharsFromSlice(slice []byte, compatible bool) (*Chars, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Chars{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Chars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Chars"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := BytesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Chars{inner: slice}, nil
}

func (s *Chars) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Chars) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Chars) Len() uint {
	return s.ItemCount()
}
func (s *Chars) IsEmpty() bool {
	return s.Len() == 0
}

// if *Bytes is nil, index is out of bounds
func (s *Chars) Get(index uint) *Bytes {
	var b *Bytes
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = BytesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = BytesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Chars) AsBuilder() CharsBuilder {
	size := s.ItemCount()
	t := NewCharsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type TypeIdTableBuilder struct {
	apply_register_cell Hash
	pre_account_cell    Hash
	proposal_cell       Hash
	ref_cell            Hash
	account_cell        Hash
	on_sale_cell        Hash
	bidding_cell        Hash
	primary_market_cell Hash
}

func (s *TypeIdTableBuilder) Build() TypeIdTable {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.apply_register_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pre_account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.proposal_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ref_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.on_sale_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.bidding_cell.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.primary_market_cell.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.apply_register_cell.AsSlice())
	b.Write(s.pre_account_cell.AsSlice())
	b.Write(s.proposal_cell.AsSlice())
	b.Write(s.ref_cell.AsSlice())
	b.Write(s.account_cell.AsSlice())
	b.Write(s.on_sale_cell.AsSlice())
	b.Write(s.bidding_cell.AsSlice())
	b.Write(s.primary_market_cell.AsSlice())
	return TypeIdTable{inner: b.Bytes()}
}

func (s *TypeIdTableBuilder) ApplyRegisterCell(v Hash) *TypeIdTableBuilder {
	s.apply_register_cell = v
	return s
}

func (s *TypeIdTableBuilder) PreAccountCell(v Hash) *TypeIdTableBuilder {
	s.pre_account_cell = v
	return s
}

func (s *TypeIdTableBuilder) ProposalCell(v Hash) *TypeIdTableBuilder {
	s.proposal_cell = v
	return s
}

func (s *TypeIdTableBuilder) RefCell(v Hash) *TypeIdTableBuilder {
	s.ref_cell = v
	return s
}

func (s *TypeIdTableBuilder) AccountCell(v Hash) *TypeIdTableBuilder {
	s.account_cell = v
	return s
}

func (s *TypeIdTableBuilder) OnSaleCell(v Hash) *TypeIdTableBuilder {
	s.on_sale_cell = v
	return s
}

func (s *TypeIdTableBuilder) BiddingCell(v Hash) *TypeIdTableBuilder {
	s.bidding_cell = v
	return s
}

func (s *TypeIdTableBuilder) PrimaryMarketCell(v Hash) *TypeIdTableBuilder {
	s.primary_market_cell = v
	return s
}

func NewTypeIdTableBuilder() *TypeIdTableBuilder {
	return &TypeIdTableBuilder{apply_register_cell: HashDefault(), pre_account_cell: HashDefault(), proposal_cell: HashDefault(), ref_cell: HashDefault(), account_cell: HashDefault(), on_sale_cell: HashDefault(), bidding_cell: HashDefault(), primary_market_cell: HashDefault()}
}

type TypeIdTable struct {
	inner []byte
}

func TypeIdTableFromSliceUnchecked(slice []byte) *TypeIdTable {
	return &TypeIdTable{inner: slice}
}
func (s *TypeIdTable) AsSlice() []byte {
	return s.inner
}

func TypeIdTableDefault() TypeIdTable {
	return *TypeIdTableFromSliceUnchecked([]byte{36, 1, 0, 0, 36, 0, 0, 0, 68, 0, 0, 0, 100, 0, 0, 0, 132, 0, 0, 0, 164, 0, 0, 0, 196, 0, 0, 0, 228, 0, 0, 0, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func TypeIdTableFromSlice(slice []byte, compatible bool) (*TypeIdTable, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 8 == 0 {
		return &TypeIdTable{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "TypeIdTable", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "TypeIdTable", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = HashFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = HashFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &TypeIdTable{inner: slice}, nil
}

func (s *TypeIdTable) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *TypeIdTable) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *TypeIdTable) Len() uint {
	return s.FieldCount()
}
func (s *TypeIdTable) IsEmpty() bool {
	return s.Len() == 0
}
func (s *TypeIdTable) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *TypeIdTable) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *TypeIdTable) ApplyRegisterCell() *Hash {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) PreAccountCell() *Hash {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) ProposalCell() *Hash {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) RefCell() *Hash {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) AccountCell() *Hash {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) OnSaleCell() *Hash {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) BiddingCell() *Hash {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return HashFromSliceUnchecked(s.inner[start:end])
}

func (s *TypeIdTable) PrimaryMarketCell() *Hash {
	var ret *Hash
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = HashFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = HashFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *TypeIdTable) AsBuilder() TypeIdTableBuilder {
	ret := NewTypeIdTableBuilder().ApplyRegisterCell(*s.ApplyRegisterCell()).PreAccountCell(*s.PreAccountCell()).ProposalCell(*s.ProposalCell()).RefCell(*s.RefCell()).AccountCell(*s.AccountCell()).OnSaleCell(*s.OnSaleCell()).BiddingCell(*s.BiddingCell()).PrimaryMarketCell(*s.PrimaryMarketCell())
	return *ret
}

type ProposalCellDataBuilder struct {
	starter_lock Script
	slices       SliceList
}

func (s *ProposalCellDataBuilder) Build() ProposalCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.starter_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.slices.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.starter_lock.AsSlice())
	b.Write(s.slices.AsSlice())
	return ProposalCellData{inner: b.Bytes()}
}

func (s *ProposalCellDataBuilder) StarterLock(v Script) *ProposalCellDataBuilder {
	s.starter_lock = v
	return s
}

func (s *ProposalCellDataBuilder) Slices(v SliceList) *ProposalCellDataBuilder {
	s.slices = v
	return s
}

func NewProposalCellDataBuilder() *ProposalCellDataBuilder {
	return &ProposalCellDataBuilder{starter_lock: ScriptDefault(), slices: SliceListDefault()}
}

type ProposalCellData struct {
	inner []byte
}

func ProposalCellDataFromSliceUnchecked(slice []byte) *ProposalCellData {
	return &ProposalCellData{inner: slice}
}
func (s *ProposalCellData) AsSlice() []byte {
	return s.inner
}

func ProposalCellDataDefault() ProposalCellData {
	return *ProposalCellDataFromSliceUnchecked([]byte{69, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func ProposalCellDataFromSlice(slice []byte, compatible bool) (*ProposalCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &ProposalCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SliceListFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &ProposalCellData{inner: slice}, nil
}

func (s *ProposalCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ProposalCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ProposalCellData) Len() uint {
	return s.FieldCount()
}
func (s *ProposalCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ProposalCellData) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *ProposalCellData) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *ProposalCellData) StarterLock() *Script {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalCellData) Slices() *SliceList {
	var ret *SliceList
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = SliceListFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SliceListFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ProposalCellData) AsBuilder() ProposalCellDataBuilder {
	ret := NewProposalCellDataBuilder().StarterLock(*s.StarterLock()).Slices(*s.Slices())
	return *ret
}

type SliceListBuilder struct {
	inner []SL
}

func (s *SliceListBuilder) Build() SliceList {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SliceList{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SliceList{inner: b.Bytes()}
}

func (s *SliceListBuilder) Set(v []SL) *SliceListBuilder {
	s.inner = v
	return s
}
func (s *SliceListBuilder) Push(v SL) *SliceListBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SliceListBuilder) Extend(iter []SL) *SliceListBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewSliceListBuilder() *SliceListBuilder {
	return &SliceListBuilder{[]SL{}}
}

type SliceList struct {
	inner []byte
}

func SliceListFromSliceUnchecked(slice []byte) *SliceList {
	return &SliceList{inner: slice}
}
func (s *SliceList) AsSlice() []byte {
	return s.inner
}

func SliceListDefault() SliceList {
	return *SliceListFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SliceListFromSlice(slice []byte, compatible bool) (*SliceList, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SliceList{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SliceList", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SliceList"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := SLFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SliceList{inner: slice}, nil
}

func (s *SliceList) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SliceList) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SliceList) Len() uint {
	return s.ItemCount()
}
func (s *SliceList) IsEmpty() bool {
	return s.Len() == 0
}

// if *SL is nil, index is out of bounds
func (s *SliceList) Get(index uint) *SL {
	var b *SL
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = SLFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = SLFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SliceList) AsBuilder() SliceListBuilder {
	size := s.ItemCount()
	t := NewSliceListBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SLBuilder struct {
	inner []ProposalItem
}

func (s *SLBuilder) Build() SL {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SL{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SL{inner: b.Bytes()}
}

func (s *SLBuilder) Set(v []ProposalItem) *SLBuilder {
	s.inner = v
	return s
}
func (s *SLBuilder) Push(v ProposalItem) *SLBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SLBuilder) Extend(iter []ProposalItem) *SLBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewSLBuilder() *SLBuilder {
	return &SLBuilder{[]ProposalItem{}}
}

type SL struct {
	inner []byte
}

func SLFromSliceUnchecked(slice []byte) *SL {
	return &SL{inner: slice}
}
func (s *SL) AsSlice() []byte {
	return s.inner
}

func SLDefault() SL {
	return *SLFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SLFromSlice(slice []byte, compatible bool) (*SL, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SL{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SL", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SL", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SL"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := ProposalItemFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SL{inner: slice}, nil
}

func (s *SL) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SL) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SL) Len() uint {
	return s.ItemCount()
}
func (s *SL) IsEmpty() bool {
	return s.Len() == 0
}

// if *ProposalItem is nil, index is out of bounds
func (s *SL) Get(index uint) *ProposalItem {
	var b *ProposalItem
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = ProposalItemFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = ProposalItemFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SL) AsBuilder() SLBuilder {
	size := s.ItemCount()
	t := NewSLBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type ProposalItemBuilder struct {
	account_id AccountId
	item_type  Uint8
	next       AccountIdOpt
}

func (s *ProposalItemBuilder) Build() ProposalItem {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.item_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.next.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account_id.AsSlice())
	b.Write(s.item_type.AsSlice())
	b.Write(s.next.AsSlice())
	return ProposalItem{inner: b.Bytes()}
}

func (s *ProposalItemBuilder) AccountId(v AccountId) *ProposalItemBuilder {
	s.account_id = v
	return s
}

func (s *ProposalItemBuilder) ItemType(v Uint8) *ProposalItemBuilder {
	s.item_type = v
	return s
}

func (s *ProposalItemBuilder) Next(v AccountIdOpt) *ProposalItemBuilder {
	s.next = v
	return s
}

func NewProposalItemBuilder() *ProposalItemBuilder {
	return &ProposalItemBuilder{account_id: AccountIdDefault(), item_type: Uint8Default(), next: AccountIdOptDefault()}
}

type ProposalItem struct {
	inner []byte
}

func ProposalItemFromSliceUnchecked(slice []byte) *ProposalItem {
	return &ProposalItem{inner: slice}
}
func (s *ProposalItem) AsSlice() []byte {
	return s.inner
}

func ProposalItemDefault() ProposalItem {
	return *ProposalItemFromSliceUnchecked([]byte{37, 0, 0, 0, 16, 0, 0, 0, 36, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ProposalItemFromSlice(slice []byte, compatible bool) (*ProposalItem, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 3 == 0 {
		return &ProposalItem{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ProposalItem", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ProposalItem", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountIdOptFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ProposalItem{inner: slice}, nil
}

func (s *ProposalItem) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ProposalItem) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ProposalItem) Len() uint {
	return s.FieldCount()
}
func (s *ProposalItem) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ProposalItem) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ProposalItem) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ProposalItem) AccountId() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalItem) ItemType() *Uint8 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *ProposalItem) Next() *AccountIdOpt {
	var ret *AccountIdOpt
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = AccountIdOptFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = AccountIdOptFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ProposalItem) AsBuilder() ProposalItemBuilder {
	ret := NewProposalItemBuilder().AccountId(*s.AccountId()).ItemType(*s.ItemType()).Next(*s.Next())
	return *ret
}

type AccountCellDataBuilder struct {
	id            AccountId
	owner         Script
	manager       Script
	account       AccountChars
	status        Uint8
	registered_at Timestamp
	expired_at    Timestamp
	records       Records
}

func (s *AccountCellDataBuilder) Build() AccountCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (8 + 1)
	offsets := make([]uint32, 0, 8)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.manager.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.status.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.registered_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.expired_at.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.records.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.id.AsSlice())
	b.Write(s.owner.AsSlice())
	b.Write(s.manager.AsSlice())
	b.Write(s.account.AsSlice())
	b.Write(s.status.AsSlice())
	b.Write(s.registered_at.AsSlice())
	b.Write(s.expired_at.AsSlice())
	b.Write(s.records.AsSlice())
	return AccountCellData{inner: b.Bytes()}
}

func (s *AccountCellDataBuilder) Id(v AccountId) *AccountCellDataBuilder {
	s.id = v
	return s
}

func (s *AccountCellDataBuilder) Owner(v Script) *AccountCellDataBuilder {
	s.owner = v
	return s
}

func (s *AccountCellDataBuilder) Manager(v Script) *AccountCellDataBuilder {
	s.manager = v
	return s
}

func (s *AccountCellDataBuilder) Account(v AccountChars) *AccountCellDataBuilder {
	s.account = v
	return s
}

func (s *AccountCellDataBuilder) Status(v Uint8) *AccountCellDataBuilder {
	s.status = v
	return s
}

func (s *AccountCellDataBuilder) RegisteredAt(v Timestamp) *AccountCellDataBuilder {
	s.registered_at = v
	return s
}

func (s *AccountCellDataBuilder) ExpiredAt(v Timestamp) *AccountCellDataBuilder {
	s.expired_at = v
	return s
}

func (s *AccountCellDataBuilder) Records(v Records) *AccountCellDataBuilder {
	s.records = v
	return s
}

func NewAccountCellDataBuilder() *AccountCellDataBuilder {
	return &AccountCellDataBuilder{id: AccountIdDefault(), owner: ScriptDefault(), manager: ScriptDefault(), account: AccountCharsDefault(), status: Uint8Default(), registered_at: TimestampDefault(), expired_at: TimestampDefault(), records: RecordsDefault()}
}

type AccountCellData struct {
	inner []byte
}

func AccountCellDataFromSliceUnchecked(slice []byte) *AccountCellData {
	return &AccountCellData{inner: slice}
}
func (s *AccountCellData) AsSlice() []byte {
	return s.inner
}

func AccountCellDataDefault() AccountCellData {
	return *AccountCellDataFromSliceUnchecked([]byte{187, 0, 0, 0, 36, 0, 0, 0, 56, 0, 0, 0, 109, 0, 0, 0, 162, 0, 0, 0, 166, 0, 0, 0, 167, 0, 0, 0, 175, 0, 0, 0, 183, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func AccountCellDataFromSlice(slice []byte, compatible bool) (*AccountCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 8 == 0 {
		return &AccountCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 8 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 8 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountIdFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AccountCharsFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint8FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = RecordsFromSlice(slice[offsets[7]:offsets[8]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountCellData{inner: slice}, nil
}

func (s *AccountCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountCellData) Len() uint {
	return s.FieldCount()
}
func (s *AccountCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountCellData) CountExtraFields() uint {
	return s.FieldCount() - 8
}

func (s *AccountCellData) HasExtraFields() bool {
	return 8 != s.FieldCount()
}

func (s *AccountCellData) Id() *AccountId {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountIdFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Owner() *Script {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Manager() *Script {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Account() *AccountChars {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Status() *Uint8 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) RegisteredAt() *Timestamp {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) ExpiredAt() *Timestamp {
	start := unpackNumber(s.inner[28:])
	end := unpackNumber(s.inner[32:])
	return TimestampFromSliceUnchecked(s.inner[start:end])
}

func (s *AccountCellData) Records() *Records {
	var ret *Records
	start := unpackNumber(s.inner[32:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[36:])
		ret = RecordsFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = RecordsFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountCellData) AsBuilder() AccountCellDataBuilder {
	ret := NewAccountCellDataBuilder().Id(*s.Id()).Owner(*s.Owner()).Manager(*s.Manager()).Account(*s.Account()).Status(*s.Status()).RegisteredAt(*s.RegisteredAt()).ExpiredAt(*s.ExpiredAt()).Records(*s.Records())
	return *ret
}

type AccountIdBuilder struct {
	inner [20]Byte
}

func NewAccountIdBuilder() *AccountIdBuilder {
	return &AccountIdBuilder{inner: [20]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *AccountIdBuilder) Build() AccountId {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return AccountId{inner: b.Bytes()}
}

func (s *AccountIdBuilder) Set(v [20]Byte) *AccountIdBuilder {
	s.inner = v
	return s
}

func (s *AccountIdBuilder) Nth0(v Byte) *AccountIdBuilder {
	s.inner[0] = v
	return s
}

func (s *AccountIdBuilder) Nth1(v Byte) *AccountIdBuilder {
	s.inner[1] = v
	return s
}

func (s *AccountIdBuilder) Nth2(v Byte) *AccountIdBuilder {
	s.inner[2] = v
	return s
}

func (s *AccountIdBuilder) Nth3(v Byte) *AccountIdBuilder {
	s.inner[3] = v
	return s
}

func (s *AccountIdBuilder) Nth4(v Byte) *AccountIdBuilder {
	s.inner[4] = v
	return s
}

func (s *AccountIdBuilder) Nth5(v Byte) *AccountIdBuilder {
	s.inner[5] = v
	return s
}

func (s *AccountIdBuilder) Nth6(v Byte) *AccountIdBuilder {
	s.inner[6] = v
	return s
}

func (s *AccountIdBuilder) Nth7(v Byte) *AccountIdBuilder {
	s.inner[7] = v
	return s
}

func (s *AccountIdBuilder) Nth8(v Byte) *AccountIdBuilder {
	s.inner[8] = v
	return s
}

func (s *AccountIdBuilder) Nth9(v Byte) *AccountIdBuilder {
	s.inner[9] = v
	return s
}

func (s *AccountIdBuilder) Nth10(v Byte) *AccountIdBuilder {
	s.inner[10] = v
	return s
}

func (s *AccountIdBuilder) Nth11(v Byte) *AccountIdBuilder {
	s.inner[11] = v
	return s
}

func (s *AccountIdBuilder) Nth12(v Byte) *AccountIdBuilder {
	s.inner[12] = v
	return s
}

func (s *AccountIdBuilder) Nth13(v Byte) *AccountIdBuilder {
	s.inner[13] = v
	return s
}

func (s *AccountIdBuilder) Nth14(v Byte) *AccountIdBuilder {
	s.inner[14] = v
	return s
}

func (s *AccountIdBuilder) Nth15(v Byte) *AccountIdBuilder {
	s.inner[15] = v
	return s
}

func (s *AccountIdBuilder) Nth16(v Byte) *AccountIdBuilder {
	s.inner[16] = v
	return s
}

func (s *AccountIdBuilder) Nth17(v Byte) *AccountIdBuilder {
	s.inner[17] = v
	return s
}

func (s *AccountIdBuilder) Nth18(v Byte) *AccountIdBuilder {
	s.inner[18] = v
	return s
}

func (s *AccountIdBuilder) Nth19(v Byte) *AccountIdBuilder {
	s.inner[19] = v
	return s
}

type AccountId struct {
	inner []byte
}

func AccountIdFromSliceUnchecked(slice []byte) *AccountId {
	return &AccountId{inner: slice}
}
func (s *AccountId) AsSlice() []byte {
	return s.inner
}

func AccountIdDefault() AccountId {
	return *AccountIdFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountIdFromSlice(slice []byte, _compatible bool) (*AccountId, error) {
	sliceLen := len(slice)
	if sliceLen != 20 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountId", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(20)}, " ")
		return nil, errors.New(errMsg)
	}
	return &AccountId{inner: slice}, nil
}

func (s *AccountId) RawData() []byte {
	return s.inner
}

func (s *AccountId) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *AccountId) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *AccountId) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *AccountId) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *AccountId) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *AccountId) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *AccountId) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *AccountId) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *AccountId) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *AccountId) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *AccountId) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *AccountId) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *AccountId) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *AccountId) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *AccountId) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *AccountId) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *AccountId) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *AccountId) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *AccountId) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *AccountId) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *AccountId) AsBuilder() AccountIdBuilder {
	t := NewAccountIdBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	return *t
}

type AccountIdOptBuilder struct {
	isNone bool
	inner  AccountId
}

func NewAccountIdOptBuilder() *AccountIdOptBuilder {
	return &AccountIdOptBuilder{isNone: true, inner: AccountIdDefault()}
}
func (s *AccountIdOptBuilder) Set(v AccountId) *AccountIdOptBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *AccountIdOptBuilder) Build() AccountIdOpt {
	var ret AccountIdOpt
	if s.isNone {
		ret = AccountIdOpt{inner: []byte{}}
	} else {
		ret = AccountIdOpt{inner: s.inner.AsSlice()}
	}
	return ret
}

type AccountIdOpt struct {
	inner []byte
}

func AccountIdOptFromSliceUnchecked(slice []byte) *AccountIdOpt {
	return &AccountIdOpt{inner: slice}
}
func (s *AccountIdOpt) AsSlice() []byte {
	return s.inner
}

func AccountIdOptDefault() AccountIdOpt {
	return *AccountIdOptFromSliceUnchecked([]byte{})
}

func AccountIdOptFromSlice(slice []byte, compatible bool) (*AccountIdOpt, error) {
	if len(slice) == 0 {
		return &AccountIdOpt{inner: slice}, nil
	}

	_, err := AccountIdFromSlice(slice, compatible)
	if err != nil {
		return nil, err
	}
	return &AccountIdOpt{inner: slice}, nil
}

func (s *AccountIdOpt) IntoAccountId() (*AccountId, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return AccountIdFromSliceUnchecked(s.AsSlice()), nil
}
func (s *AccountIdOpt) IsSome() bool {
	return len(s.inner) != 0
}
func (s *AccountIdOpt) IsNone() bool {
	return len(s.inner) == 0
}
func (s *AccountIdOpt) AsBuilder() AccountIdOptBuilder {
	var ret = NewAccountIdOptBuilder()
	if s.IsSome() {
		ret.Set(*AccountIdFromSliceUnchecked(s.AsSlice()))
	}
	return *ret
}

type RecordBuilder struct {
	record_type  Bytes
	record_label Bytes
	record_value Bytes
	record_ttl   Uint32
}

func (s *RecordBuilder) Build() Record {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_label.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_value.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.record_ttl.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.record_type.AsSlice())
	b.Write(s.record_label.AsSlice())
	b.Write(s.record_value.AsSlice())
	b.Write(s.record_ttl.AsSlice())
	return Record{inner: b.Bytes()}
}

func (s *RecordBuilder) RecordType(v Bytes) *RecordBuilder {
	s.record_type = v
	return s
}

func (s *RecordBuilder) RecordLabel(v Bytes) *RecordBuilder {
	s.record_label = v
	return s
}

func (s *RecordBuilder) RecordValue(v Bytes) *RecordBuilder {
	s.record_value = v
	return s
}

func (s *RecordBuilder) RecordTtl(v Uint32) *RecordBuilder {
	s.record_ttl = v
	return s
}

func NewRecordBuilder() *RecordBuilder {
	return &RecordBuilder{record_type: BytesDefault(), record_label: BytesDefault(), record_value: BytesDefault(), record_ttl: Uint32Default()}
}

type Record struct {
	inner []byte
}

func RecordFromSliceUnchecked(slice []byte) *Record {
	return &Record{inner: slice}
}
func (s *Record) AsSlice() []byte {
	return s.inner
}

func RecordDefault() Record {
	return *RecordFromSliceUnchecked([]byte{36, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func RecordFromSlice(slice []byte, compatible bool) (*Record, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
		return &Record{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Record", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Record", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &Record{inner: slice}, nil
}

func (s *Record) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Record) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Record) Len() uint {
	return s.FieldCount()
}
func (s *Record) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Record) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *Record) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *Record) RecordType() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordLabel() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordValue() *Bytes {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Record) RecordTtl() *Uint32 {
	var ret *Uint32
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = Uint32FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint32FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Record) AsBuilder() RecordBuilder {
	ret := NewRecordBuilder().RecordType(*s.RecordType()).RecordLabel(*s.RecordLabel()).RecordValue(*s.RecordValue()).RecordTtl(*s.RecordTtl())
	return *ret
}

type RecordsBuilder struct {
	inner []Record
}

func (s *RecordsBuilder) Build() Records {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return Records{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return Records{inner: b.Bytes()}
}

func (s *RecordsBuilder) Set(v []Record) *RecordsBuilder {
	s.inner = v
	return s
}
func (s *RecordsBuilder) Push(v Record) *RecordsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *RecordsBuilder) Extend(iter []Record) *RecordsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewRecordsBuilder() *RecordsBuilder {
	return &RecordsBuilder{[]Record{}}
}

type Records struct {
	inner []byte
}

func RecordsFromSliceUnchecked(slice []byte) *Records {
	return &Records{inner: slice}
}
func (s *Records) AsSlice() []byte {
	return s.inner
}

func RecordsDefault() Records {
	return *RecordsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func RecordsFromSlice(slice []byte, compatible bool) (*Records, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &Records{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Records", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Records", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "Records"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := RecordFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &Records{inner: slice}, nil
}

func (s *Records) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Records) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Records) Len() uint {
	return s.ItemCount()
}
func (s *Records) IsEmpty() bool {
	return s.Len() == 0
}

// if *Record is nil, index is out of bounds
func (s *Records) Get(index uint) *Record {
	var b *Record
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = RecordFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = RecordFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *Records) AsBuilder() RecordsBuilder {
	size := s.ItemCount()
	t := NewRecordsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type PreAccountCellDataBuilder struct {
	account     AccountChars
	refund_lock Script
	owner_lock  Script
	price       PriceConfig
	quote       Uint32
	created_at  Timestamp
}

func (s *PreAccountCellDataBuilder) Build() PreAccountCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (6 + 1)
	offsets := make([]uint32, 0, 6)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.account.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.refund_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.owner_lock.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.quote.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.created_at.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.account.AsSlice())
	b.Write(s.refund_lock.AsSlice())
	b.Write(s.owner_lock.AsSlice())
	b.Write(s.price.AsSlice())
	b.Write(s.quote.AsSlice())
	b.Write(s.created_at.AsSlice())
	return PreAccountCellData{inner: b.Bytes()}
}

func (s *PreAccountCellDataBuilder) Account(v AccountChars) *PreAccountCellDataBuilder {
	s.account = v
	return s
}

func (s *PreAccountCellDataBuilder) RefundLock(v Script) *PreAccountCellDataBuilder {
	s.refund_lock = v
	return s
}

func (s *PreAccountCellDataBuilder) OwnerLock(v Script) *PreAccountCellDataBuilder {
	s.owner_lock = v
	return s
}

func (s *PreAccountCellDataBuilder) Price(v PriceConfig) *PreAccountCellDataBuilder {
	s.price = v
	return s
}

func (s *PreAccountCellDataBuilder) Quote(v Uint32) *PreAccountCellDataBuilder {
	s.quote = v
	return s
}

func (s *PreAccountCellDataBuilder) CreatedAt(v Timestamp) *PreAccountCellDataBuilder {
	s.created_at = v
	return s
}

func NewPreAccountCellDataBuilder() *PreAccountCellDataBuilder {
	return &PreAccountCellDataBuilder{account: AccountCharsDefault(), refund_lock: ScriptDefault(), owner_lock: ScriptDefault(), price: PriceConfigDefault(), quote: Uint32Default(), created_at: TimestampDefault()}
}

type PreAccountCellData struct {
	inner []byte
}

func PreAccountCellDataFromSliceUnchecked(slice []byte) *PreAccountCellData {
	return &PreAccountCellData{inner: slice}
}
func (s *PreAccountCellData) AsSlice() []byte {
	return s.inner
}

func PreAccountCellDataDefault() PreAccountCellData {
	return *PreAccountCellDataFromSliceUnchecked([]byte{183, 0, 0, 0, 28, 0, 0, 0, 32, 0, 0, 0, 85, 0, 0, 0, 138, 0, 0, 0, 171, 0, 0, 0, 175, 0, 0, 0, 4, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 0, 0, 0, 16, 0, 0, 0, 17, 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func PreAccountCellDataFromSlice(slice []byte, compatible bool) (*PreAccountCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 6 == 0 {
		return &PreAccountCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "PreAccountCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 6 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 6 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "PreAccountCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = AccountCharsFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = PriceConfigFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = TimestampFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	return &PreAccountCellData{inner: slice}, nil
}

func (s *PreAccountCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *PreAccountCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *PreAccountCellData) Len() uint {
	return s.FieldCount()
}
func (s *PreAccountCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *PreAccountCellData) CountExtraFields() uint {
	return s.FieldCount() - 6
}

func (s *PreAccountCellData) HasExtraFields() bool {
	return 6 != s.FieldCount()
}

func (s *PreAccountCellData) Account() *AccountChars {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return AccountCharsFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) RefundLock() *Script {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) OwnerLock() *Script {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) Price() *PriceConfig {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return PriceConfigFromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) Quote() *Uint32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *PreAccountCellData) CreatedAt() *Timestamp {
	var ret *Timestamp
	start := unpackNumber(s.inner[24:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[28:])
		ret = TimestampFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = TimestampFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *PreAccountCellData) AsBuilder() PreAccountCellDataBuilder {
	ret := NewPreAccountCellDataBuilder().Account(*s.Account()).RefundLock(*s.RefundLock()).OwnerLock(*s.OwnerLock()).Price(*s.Price()).Quote(*s.Quote()).CreatedAt(*s.CreatedAt())
	return *ret
}

type AccountCharsBuilder struct {
	inner []AccountChar
}

func (s *AccountCharsBuilder) Build() AccountChars {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return AccountChars{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return AccountChars{inner: b.Bytes()}
}

func (s *AccountCharsBuilder) Set(v []AccountChar) *AccountCharsBuilder {
	s.inner = v
	return s
}
func (s *AccountCharsBuilder) Push(v AccountChar) *AccountCharsBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *AccountCharsBuilder) Extend(iter []AccountChar) *AccountCharsBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}

func NewAccountCharsBuilder() *AccountCharsBuilder {
	return &AccountCharsBuilder{[]AccountChar{}}
}

type AccountChars struct {
	inner []byte
}

func AccountCharsFromSliceUnchecked(slice []byte) *AccountChars {
	return &AccountChars{inner: slice}
}
func (s *AccountChars) AsSlice() []byte {
	return s.inner
}

func AccountCharsDefault() AccountChars {
	return *AccountCharsFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func AccountCharsFromSlice(slice []byte, compatible bool) (*AccountChars, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &AccountChars{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	itemCount := offsetFirst/4 - 1
	headerSize := HeaderSizeUint * (uint32(itemCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChars", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][4*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChars"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := AccountCharFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &AccountChars{inner: slice}, nil
}

func (s *AccountChars) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountChars) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountChars) Len() uint {
	return s.ItemCount()
}
func (s *AccountChars) IsEmpty() bool {
	return s.Len() == 0
}

// if *AccountChar is nil, index is out of bounds
func (s *AccountChars) Get(index uint) *AccountChar {
	var b *AccountChar
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = AccountCharFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = AccountCharFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *AccountChars) AsBuilder() AccountCharsBuilder {
	size := s.ItemCount()
	t := NewAccountCharsBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type AccountCharBuilder struct {
	char_set_name Uint32
	bytes         Bytes
}

func (s *AccountCharBuilder) Build() AccountChar {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.char_set_name.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.bytes.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.char_set_name.AsSlice())
	b.Write(s.bytes.AsSlice())
	return AccountChar{inner: b.Bytes()}
}

func (s *AccountCharBuilder) CharSetName(v Uint32) *AccountCharBuilder {
	s.char_set_name = v
	return s
}

func (s *AccountCharBuilder) Bytes(v Bytes) *AccountCharBuilder {
	s.bytes = v
	return s
}

func NewAccountCharBuilder() *AccountCharBuilder {
	return &AccountCharBuilder{char_set_name: Uint32Default(), bytes: BytesDefault()}
}

type AccountChar struct {
	inner []byte
}

func AccountCharFromSliceUnchecked(slice []byte) *AccountChar {
	return &AccountChar{inner: slice}
}
func (s *AccountChar) AsSlice() []byte {
	return s.inner
}

func AccountCharDefault() AccountChar {
	return *AccountCharFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func AccountCharFromSlice(slice []byte, compatible bool) (*AccountChar, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 2 == 0 {
		return &AccountChar{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "AccountChar", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "AccountChar", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &AccountChar{inner: slice}, nil
}

func (s *AccountChar) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *AccountChar) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *AccountChar) Len() uint {
	return s.FieldCount()
}
func (s *AccountChar) IsEmpty() bool {
	return s.Len() == 0
}
func (s *AccountChar) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *AccountChar) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *AccountChar) CharSetName() *Uint32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint32FromSliceUnchecked(s.inner[start:end])
}

func (s *AccountChar) Bytes() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *AccountChar) AsBuilder() AccountCharBuilder {
	ret := NewAccountCharBuilder().CharSetName(*s.CharSetName()).Bytes(*s.Bytes())
	return *ret
}

type OnSaleCellDataBuilder struct {
	price Uint64
}

func (s *OnSaleCellDataBuilder) Build() OnSaleCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (1 + 1)
	offsets := make([]uint32, 0, 1)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.price.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.price.AsSlice())
	return OnSaleCellData{inner: b.Bytes()}
}

func (s *OnSaleCellDataBuilder) Price(v Uint64) *OnSaleCellDataBuilder {
	s.price = v
	return s
}

func NewOnSaleCellDataBuilder() *OnSaleCellDataBuilder {
	return &OnSaleCellDataBuilder{price: Uint64Default()}
}

type OnSaleCellData struct {
	inner []byte
}

func OnSaleCellDataFromSliceUnchecked(slice []byte) *OnSaleCellData {
	return &OnSaleCellData{inner: slice}
}
func (s *OnSaleCellData) AsSlice() []byte {
	return s.inner
}

func OnSaleCellDataDefault() OnSaleCellData {
	return *OnSaleCellDataFromSliceUnchecked([]byte{16, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func OnSaleCellDataFromSlice(slice []byte, compatible bool) (*OnSaleCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 1 == 0 {
		return &OnSaleCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "OnSaleCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 1 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 1 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "OnSaleCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint64FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	return &OnSaleCellData{inner: slice}, nil
}

func (s *OnSaleCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *OnSaleCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *OnSaleCellData) Len() uint {
	return s.FieldCount()
}
func (s *OnSaleCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *OnSaleCellData) CountExtraFields() uint {
	return s.FieldCount() - 1
}

func (s *OnSaleCellData) HasExtraFields() bool {
	return 1 != s.FieldCount()
}

func (s *OnSaleCellData) Price() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[4:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[8:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *OnSaleCellData) AsBuilder() OnSaleCellDataBuilder {
	ret := NewOnSaleCellDataBuilder().Price(*s.Price())
	return *ret
}

type BiddingCellDataBuilder struct {
	market_type    Uint8
	starting_price Uint64
	current_price  Uint64
	current_bidder ScriptOpt
}

func (s *BiddingCellDataBuilder) Build() BiddingCellData {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.market_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.starting_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.current_price.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.current_bidder.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.market_type.AsSlice())
	b.Write(s.starting_price.AsSlice())
	b.Write(s.current_price.AsSlice())
	b.Write(s.current_bidder.AsSlice())
	return BiddingCellData{inner: b.Bytes()}
}

func (s *BiddingCellDataBuilder) MarketType(v Uint8) *BiddingCellDataBuilder {
	s.market_type = v
	return s
}

func (s *BiddingCellDataBuilder) StartingPrice(v Uint64) *BiddingCellDataBuilder {
	s.starting_price = v
	return s
}

func (s *BiddingCellDataBuilder) CurrentPrice(v Uint64) *BiddingCellDataBuilder {
	s.current_price = v
	return s
}

func (s *BiddingCellDataBuilder) CurrentBidder(v ScriptOpt) *BiddingCellDataBuilder {
	s.current_bidder = v
	return s
}

func NewBiddingCellDataBuilder() *BiddingCellDataBuilder {
	return &BiddingCellDataBuilder{market_type: Uint8Default(), starting_price: Uint64Default(), current_price: Uint64Default(), current_bidder: ScriptOptDefault()}
}

type BiddingCellData struct {
	inner []byte
}

func BiddingCellDataFromSliceUnchecked(slice []byte) *BiddingCellData {
	return &BiddingCellData{inner: slice}
}
func (s *BiddingCellData) AsSlice() []byte {
	return s.inner
}

func BiddingCellDataDefault() BiddingCellData {
	return *BiddingCellDataFromSliceUnchecked([]byte{37, 0, 0, 0, 20, 0, 0, 0, 21, 0, 0, 0, 29, 0, 0, 0, 37, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func BiddingCellDataFromSlice(slice []byte, compatible bool) (*BiddingCellData, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BiddingCellData", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint && 4 == 0 {
		return &BiddingCellData{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if offsetFirst%4 != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "BiddingCellData", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := offsetFirst/4 - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	headerSize := HeaderSizeUint * (uint32(fieldCount) + 1)
	if uint32(sliceLen) < headerSize {
		errMsg := strings.Join([]string{"HeaderIsBroken", "BiddingCellData", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(headerSize))}, " ")
		return nil, errors.New(errMsg)
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Uint8FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ScriptOptFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &BiddingCellData{inner: slice}, nil
}

func (s *BiddingCellData) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *BiddingCellData) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *BiddingCellData) Len() uint {
	return s.FieldCount()
}
func (s *BiddingCellData) IsEmpty() bool {
	return s.Len() == 0
}
func (s *BiddingCellData) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *BiddingCellData) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *BiddingCellData) MarketType() *Uint8 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Uint8FromSliceUnchecked(s.inner[start:end])
}

func (s *BiddingCellData) StartingPrice() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *BiddingCellData) CurrentPrice() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *BiddingCellData) CurrentBidder() *ScriptOpt {
	var ret *ScriptOpt
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = ScriptOptFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ScriptOptFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *BiddingCellData) AsBuilder() BiddingCellDataBuilder {
	ret := NewBiddingCellDataBuilder().MarketType(*s.MarketType()).StartingPrice(*s.StartingPrice()).CurrentPrice(*s.CurrentPrice()).CurrentBidder(*s.CurrentBidder())
	return *ret
}
